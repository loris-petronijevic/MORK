<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Multi-Order Runge-Kutta methods (MORK)"><title>MORK - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="MORK" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../MORK/index.html">MORK</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#multi-order-runge-kutta-methods-mork" title="Multi-Order Runge-Kutta methods (MORK)">Multi-Order Runge-Kutta methods (MORK)</a></li><li><a href="#usage" title="Usage">Usage</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>MORK</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/MORK/lib.rs.html#1-118">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="multi-order-runge-kutta-methods-mork"><a class="doc-anchor" href="#multi-order-runge-kutta-methods-mork">§</a>Multi-Order Runge-Kutta methods (MORK)</h2>
<p><code>MORK</code> is an implementation of general multi-order Runge-Kutta methods (<a href="GMORK/index.html" title="mod MORK::GMORK">GMORK</a>), node-determined Runge-Kutta methods (<a href="NDMORK/index.html" title="mod MORK::NDMORK">NDMORK</a>) and Runge-Kutta methods (<a href="RK/index.html" title="mod MORK::RK">RK</a>), as described in the paper <a href="https://doi.org/10.48550/arXiv.2509.23513">“Multi-order Runge-Kutta methods or how to numerically solve initial value problems of any order”</a>.</p>
<p>All methods implement the <a href="trait.Solver.html" title="trait MORK::Solver">Solver</a> trait, which requires the implementation of an <a href="trait.Solver.html#tymethod.approximate" title="method MORK::Solver::approximate">approximate</a> function. This function, given a differential equation function, initial instant, initial values, and a step size, returns the approximation of the method/struct which implements this trait.</p>
<p>Some Runge-Kutta methods (<a href="RK/list/index.html" title="mod MORK::RK::list">RK::list</a>) and node-determined multi-order Runge-Kutta methods (<a href="NDMORK/list/index.html" title="mod MORK::NDMORK::list">NDMORK::list</a>) are already implemented.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>To approximate the solution of an initial value problem, we first need to define an initial value problem. We here consider a system of linear differential equations of dimension two, the initial value problem :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>d^<span class="number">2 </span>y1(t) = f1(t,d y1(t), y1(t),y2 (t)) = - <span class="number">2 </span>d y1(t) - y1(t) - y2(t)
d y2(t) = f2(t,d y1(t), y1(t), y2(t)) = <span class="number">2 </span>d y1(t) + <span class="number">2 </span>y1(t) + y2(t)
t0 = <span class="number">0
</span>d y1(t0) = -<span class="number">1
</span>y1(t0) = <span class="number">0.5
</span>y2(t0) = <span class="number">1 </span></code></pre></div>
<p>We define the function <code>f = (f1,f2)</code> and the initial values <code>y_initial = ((d y1(t0), y1(t0)), y2(t0))</code> :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = |_t:f64,y:<span class="kw-2">&amp;</span>Vec&lt;Vec&lt;f64&gt;&gt;| <span class="macro">vec!</span>[-<span class="number">2. </span>* y[<span class="number">0</span>][<span class="number">0</span>] - y[<span class="number">0</span>][<span class="number">1</span>] - y[<span class="number">1</span>][<span class="number">0</span>], <span class="number">2. </span>* y[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">2. </span>* y[<span class="number">0</span>][<span class="number">1</span>] + y[<span class="number">1</span>][<span class="number">0</span>]];
<span class="kw">let </span>t0 = <span class="number">0.</span>;
<span class="kw">let </span>y_initial = <span class="macro">vec!</span>[<span class="macro">vec!</span>[-<span class="number">1.</span>,<span class="number">0.5</span>],<span class="macro">vec!</span>[<span class="number">1.</span>]];</code></pre></div>
<p>Keep in mind that the firs index of <code>y_initial</code> distinguishes the different entries <code>y1</code> and <code>y2</code>, the second index is for the derivative. The highest derivative is indexed using 0, and as the derivative decreases the index increases. We then choose the method we want to use, we here choose MORK4b :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>method = MORK4b(); </code></pre></div>
<p>For this example we will simply iterate a certain number of time the method with a constant step size, we hence define :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>iterations = <span class="number">100</span>;
<span class="kw">let </span>h = <span class="number">0.01</span>;</code></pre></div>
<p>To apply the method we first initialize the approximations to the initial values, then use the <a href="trait.Solver.html#tymethod.approximate" title="method MORK::Solver::approximate">approximate</a> function, a function that all struct with the trait <a href="trait.Solver.html" title="trait MORK::Solver">Solver</a> implement.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>y = y_initial.clone();

<span class="kw">for _ in </span><span class="number">0</span>..iterations {
    y = method.approximate(t0, h, <span class="kw-2">&amp;</span>f, <span class="kw-2">&amp;</span>y);
}</code></pre></div>
<p>To measure the error of the approximation we first need the solution of the initial value problem. For this particular problem the solution is :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>d y1(t) = -<span class="number">1</span>/<span class="number">2 </span>(e^(-t) + cos(t))
y1(t) = <span class="number">1</span>/<span class="number">2 </span>(e^(-t)-sin(t))
y2(t) = cos(t)</code></pre></div>
<p>We hence define a solution function :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>solution = |t: f64| <span class="macro">vec!</span>[<span class="macro">vec!</span>[-<span class="number">0.5 </span>* ((-t).exp() + t.cos()), <span class="number">0.5 </span>* ((-t).exp() - t.sin())],<span class="macro">vec!</span>[t.cos()]];</code></pre></div>
<p>We then compute the error at the final time :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>exact = solution(h * iterations <span class="kw">as </span>f64);
	
<span class="kw">let </span>error = <span class="macro">vec!</span>[<span class="macro">vec!</span>[(exact[<span class="number">0</span>][<span class="number">0</span>]-y[<span class="number">0</span>][<span class="number">0</span>]).abs(),(exact[<span class="number">0</span>][<span class="number">1</span>]-y[<span class="number">0</span>][<span class="number">1</span>]).abs()],<span class="macro">vec!</span>[(exact[<span class="number">1</span>][<span class="number">0</span>]-y[<span class="number">1</span>][<span class="number">0</span>]).abs()]];</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="GMORK/index.html" title="mod MORK::GMORK">GMORK</a></div><div class="desc docblock-short">Implementation of <a href="GMORK/struct.GMORK.html" title="struct MORK::GMORK::GMORK">GMORK</a>.</div></li><li><div class="item-name"><a class="mod" href="NDMORK/index.html" title="mod MORK::NDMORK">NDMORK</a></div><div class="desc docblock-short">Implementation of <a href="NDMORK/struct.NDMORK.html" title="struct MORK::NDMORK::NDMORK">NDMORK</a> and a list of node-determined methods.</div></li><li><div class="item-name"><a class="mod" href="RK/index.html" title="mod MORK::RK">RK</a></div><div class="desc docblock-short">Implementation of <a href="RK/struct.RK.html" title="struct MORK::RK::RK">RK</a> and a list of Runge-Kutta methods.</div></li><li><div class="item-name"><a class="mod" href="graph/index.html" title="mod MORK::graph">graph</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.SCC.html" title="enum MORK::SCC">SCC</a></div><div class="desc docblock-short"><a href="enum.SCC.html" title="enum MORK::SCC">SCC</a> allows to distinguish between implicit and explicit strongly connected components.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Solver.html" title="trait MORK::Solver">Solver</a></div><div class="desc docblock-short"><a href="trait.Solver.html" title="trait MORK::Solver">Solver</a> is the used to indicate that a struct is a numerical scheme and can hence approximate the solution of an initial value problem.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.create_computation_order.html" title="fn MORK::create_computation_order">create_<wbr>computation_<wbr>order</a></div><div class="desc docblock-short"><a href="fn.create_computation_order.html" title="fn MORK::create_computation_order">create_computation_order</a> takes the maximum weight digraph of a method and outputs an order of computation.</div></li></ul></section></div></main></body></html>